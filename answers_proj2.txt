1. Describe any design decisions you made, including your choice of page eviction policy. Describe briefly your insertion
and deletion methods in B+ tree.
	
	BufferPool.java:
		- With the ConcurrentHashMap<PageId, Page> cacheMap created in proj1, we used an AtomicInteger to track the number
		of present pages in the buffer pool. Whenever we add or remove pid in the cacheMap, the AtomicInteger is adjusted
		accordingly.
		- We chose Least Recently Used policy to evict pages whenever there is an insufficient space in the buffer pool.
		- We ensured that flushPage and flushAllPages methods will not evict pages from the buffer pool. flushPage writes
		any dirty page to disk and mark it as not dirty and leave it in the BufferPool.
		
	BTreeFile.java:
		findLeafPage():
		- As per project description page we are assuming that only leaf and internal pages will be passed to this function.
		- When pgcateg() equal to BTreePageId.LEAF, we just fetch the page from the buffer pool and return it.
		- If the provided value is null, we recurse on the left-most child every time in order to find the left-most leaf page.
		Once the correct leaf page is found, we are returning it.
		- we search through internal nodes until we reaches the leaf page corresponding to the provided key value. we iterate
		through the entries in the internal page using the interface BTreeEntry and compare the entry value to the provided key
		value.
		
		splitLeafPage() and splitInternalPage():
		- As per project description, we added the first tuple in the second page to the parent whenever page splits happen.
		- When splitting the leaf page we copied the key up to the parent page, whereas in internal pages we pushed the key up
		to the parent page.
		- After setting the left and right siblings of the leaf pages, the copy key has been inserted into the parent using
		insertEntry through the BTreeEntry interface and updateParentPointers has been called to update the parent pointers
		of all the children.
		- Whenever the Internal page has been split, the corresponding push key is added to parent page after setting the left
		and right child. At the end the dirty pages and the parent pointers has been updated.
		
		stealFromLeafPage(), stealFromLeftInternalPage() and stealFromRightInternalPage():
		- While deleting the leaf and internal pages, numTuple and numEntries difference has been calculated to see whether
		it is less than half full.
		- If the siblings has tuples or entries we can steal from them to balance, and the parent entries has been updated
		accordingly after updating left and right siblings.
		- The same applies for internal page as well, after updating the left and right child we updated entry in the parent
		page. Finally parent pointers and dirty pages has been updated accordingly.
		
		mergeLeafPages() and mergeInternalPages():
		- While merging the leaf page, we moved all tuples from right page to left page and adjusted the left and right siblings.
		- We deleted entry from the parent as well and then we set that page as empty for future use, which will be used
		whenever getEmptyPage has been called.
		- In Internal pages, we did the same as leaf pages. We moved all entries from right page to left and we deleted 
		the parent entry. Finally we updated the parent pointers and set the empty pages for later use.
		
	Predicate.java:
	IndexPredicate.java:
		- We initialize the getters and setters in Predicate and IndexPredicate class which has been used in BTreeFile class.

2. Discuss and justify any changes you made to the API.
	No, We didnâ€™t change any given APIs.

3. Describe any missing or incomplete elements of your code.
	Completed all the exercises given in the project description and ran the Junit tests accordingly to verify the implementations.

4. Describe how long you spent on the project, and whether there was anything you found particularly difficult or confusing.
	- Overall we have spent around 22-24 hrs for proj2 and we spent most of our time in understanding and implementing the
	BTreeFile class.